{
  "version": 3,
  "sources": ["../../crypto-engine/node_modules/@noble/hashes/src/_u64.ts", "../../crypto-engine/node_modules/@noble/hashes/src/utils.ts", "../../crypto-engine/node_modules/@noble/hashes/src/_blake.ts", "../../crypto-engine/node_modules/@noble/hashes/src/blake2.ts", "../../crypto-engine/node_modules/@noble/hashes/src/argon2.ts", "../../crypto-engine/src/argon2.ts", "../../crypto-engine/src/aes.ts", "../src/background/service-worker.ts"],
  "sourcesContent": ["/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from './utils.ts';\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA: Uint8Array = /* @__PURE__ */ Uint8Array.from([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  // Blake1, unused in others\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n\n// prettier-ignore\nexport type Num4 = { a: number; b: number; c: number; d: number; };\n\n// Mixing function G splitted in two halfs\nexport function G1s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 16);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 12);\n  return { a, b, c, d };\n}\n\nexport function G2s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 8);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 7);\n  return { a, b, c, d };\n}\n", "/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from './_blake.ts';\nimport { SHA256_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32,\n  type CHashO, type Input\n} from './utils.ts';\n\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\nexport type Blake2Opts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction checkBlake2Opts(\n  outputLen: number,\n  opts: Blake2Opts | undefined = {},\n  keyLen: number,\n  saltLen: number,\n  persLen: number\n) {\n  anumber(keyLen);\n  if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n  const { key, salt, personalization } = opts;\n  if (key !== undefined && (key.length < 1 || key.length > keyLen))\n    throw new Error('key length must be undefined or 1..' + keyLen);\n  if (salt !== undefined && salt.length !== saltLen)\n    throw new Error('salt must be undefined or ' + saltLen);\n  if (personalization !== undefined && personalization.length !== persLen)\n    throw new Error('personalization must be undefined or ' + persLen);\n}\n\n/** Class, from which others are subclassed. */\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected finished = false;\n  protected destroyed = false;\n  protected length: number = 0;\n  protected pos: number = 0;\n  readonly blockLen: number;\n  readonly outputLen: number;\n\n  constructor(blockLen: number, outputLen: number) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, false);\n        swap32IfBE(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        swap32IfBE(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        swap32IfBE(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(pos));\n    swap32IfBE(buffer32);\n    this.compress(buffer32, 0, true);\n    swap32IfBE(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.buffer.set(buffer);\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    // @ts-ignore\n    to.outputLen = outputLen;\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\nexport class BLAKE2b extends BLAKE2<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = B2B_IV[0] | 0;\n  private v0h = B2B_IV[1] | 0;\n  private v1l = B2B_IV[2] | 0;\n  private v1h = B2B_IV[3] | 0;\n  private v2l = B2B_IV[4] | 0;\n  private v2h = B2B_IV[5] | 0;\n  private v3l = B2B_IV[6] | 0;\n  private v3h = B2B_IV[7] | 0;\n  private v4l = B2B_IV[8] | 0;\n  private v4h = B2B_IV[9] | 0;\n  private v5l = B2B_IV[10] | 0;\n  private v5h = B2B_IV[11] | 0;\n  private v6l = B2B_IV[12] | 0;\n  private v6h = B2B_IV[13] | 0;\n  private v7l = B2B_IV[14] | 0;\n  private v7h = B2B_IV[15] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n    super(128, olen);\n    checkBlake2Opts(olen, opts, 64, 16, 16);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt);\n      this.v4l ^= swap8IfBE(slt[0]);\n      this.v4h ^= swap8IfBE(slt[1]);\n      this.v5l ^= swap8IfBE(slt[2]);\n      this.v5h ^= swap8IfBE(slt[3]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization);\n      this.v6l ^= swap8IfBE(pers[0]);\n      this.v6h ^= swap8IfBE(pers[1]);\n      this.v7l ^= swap8IfBE(pers[2]);\n      this.v7h ^= swap8IfBE(pers[3]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ): void {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n    BBUF.set(B2B_IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BBUF[28] = ~BBUF[28];\n      BBUF[29] = ~BBUF[29];\n    }\n    let j = 0;\n    const s = BSIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BBUF[0] ^ BBUF[16];\n    this.v0h ^= BBUF[1] ^ BBUF[17];\n    this.v1l ^= BBUF[2] ^ BBUF[18];\n    this.v1h ^= BBUF[3] ^ BBUF[19];\n    this.v2l ^= BBUF[4] ^ BBUF[20];\n    this.v2h ^= BBUF[5] ^ BBUF[21];\n    this.v3l ^= BBUF[6] ^ BBUF[22];\n    this.v3h ^= BBUF[7] ^ BBUF[23];\n    this.v4l ^= BBUF[8] ^ BBUF[24];\n    this.v4h ^= BBUF[9] ^ BBUF[25];\n    this.v5l ^= BBUF[10] ^ BBUF[26];\n    this.v5h ^= BBUF[11] ^ BBUF[27];\n    this.v6l ^= BBUF[12] ^ BBUF[28];\n    this.v6h ^= BBUF[13] ^ BBUF[29];\n    this.v7l ^= BBUF[14] ^ BBUF[30];\n    this.v7h ^= BBUF[15] ^ BBUF[31];\n    clean(BBUF);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2b, Blake2Opts>(\n  (opts) => new BLAKE2b(opts)\n);\n\n// =================\n// Blake2S\n// =================\n\n// prettier-ignore\nexport type Num16 = {\n  v0: number; v1: number; v2: number; v3: number;\n  v4: number; v5: number; v6: number; v7: number;\n  v8: number; v9: number; v10: number; v11: number;\n  v12: number; v13: number; v14: number; v15: number;\n};\n\n// prettier-ignore\nexport function compress(s: Uint8Array, offset: number, msg: Uint32Array, rounds: number,\n  v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number,\n  v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n): Num16 {\n  let j = 0;\n  for (let i = 0; i < rounds; i++) {\n    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n\n    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n  }\n  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\n\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2<BLAKE2s> {\n  // Internal state, same as SHA-256\n  private v0 = B2S_IV[0] | 0;\n  private v1 = B2S_IV[1] | 0;\n  private v2 = B2S_IV[2] | 0;\n  private v3 = B2S_IV[3] | 0;\n  private v4 = B2S_IV[4] | 0;\n  private v5 = B2S_IV[5] | 0;\n  private v6 = B2S_IV[6] | 0;\n  private v7 = B2S_IV[7] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    super(64, olen);\n    checkBlake2Opts(olen, opts, 32, 8, 8);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt as Uint8Array);\n      this.v4 ^= swap8IfBE(slt[0]);\n      this.v5 ^= swap8IfBE(slt[1]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization as Uint8Array);\n      this.v6 ^= swap8IfBE(pers[0]);\n      this.v7 ^= swap8IfBE(pers[1]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      abytes(key);\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n    return [v0, v1, v2, v3, v4, v5, v6, v7];\n  }\n  // prettier-ignore\n  protected set(\n    v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number\n  ): void {\n    this.v0 = v0 | 0;\n    this.v1 = v1 | 0;\n    this.v2 = v2 | 0;\n    this.v3 = v3 | 0;\n    this.v4 = v4 | 0;\n    this.v5 = v5 | 0;\n    this.v6 = v6 | 0;\n    this.v7 = v7 | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    const { h, l } = u64.fromBig(BigInt(this.length));\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        BSIGMA, offset, msg, 10,\n        this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7,\n        B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]\n      );\n    this.v0 ^= v0 ^ v8;\n    this.v1 ^= v1 ^ v9;\n    this.v2 ^= v2 ^ v10;\n    this.v3 ^= v3 ^ v11;\n    this.v4 ^= v4 ^ v12;\n    this.v5 ^= v5 ^ v13;\n    this.v6 ^= v6 ^ v14;\n    this.v7 ^= v7 ^ v15;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2s, Blake2Opts>(\n  (opts) => new BLAKE2s(opts)\n);\n", "/**\n * Argon2 KDF from RFC 9106. Can be used to create a key from password and salt.\n * We suggest to use Scrypt. JS Argon is 2-10x slower than native code because of 64-bitness:\n * * argon uses uint64, but JS doesn't have fast uint64array\n * * uint64 multiplication is 1/3 of time\n * * `P` function would be very nice with u64, because most of value will be in registers,\n *   hovewer with u32 it will require 32 registers, which is too much.\n * * JS arrays do slow bound checks, so reading from `A2_BUF` slows it down\n * @module\n */\nimport { add3H, add3L, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL } from './_u64.ts';\nimport { blake2b } from './blake2.ts';\nimport { abytes, clean, kdfInputToBytes, nextTick, u32, u8, type KDFInput } from './utils.ts';\n\nconst AT = { Argond2d: 0, Argon2i: 1, Argon2id: 2 } as const;\ntype Types = (typeof AT)[keyof typeof AT];\n\nconst ARGON2_SYNC_POINTS = 4;\nconst abytesOrZero = (buf?: KDFInput) => {\n  if (buf === undefined) return Uint8Array.of();\n  return kdfInputToBytes(buf);\n};\n\n// u32 * u32 = u64\nfunction mul(a: number, b: number) {\n  const aL = a & 0xffff;\n  const aH = a >>> 16;\n  const bL = b & 0xffff;\n  const bH = b >>> 16;\n  const ll = Math.imul(aL, bL);\n  const hl = Math.imul(aH, bL);\n  const lh = Math.imul(aL, bH);\n  const hh = Math.imul(aH, bH);\n  const carry = (ll >>> 16) + (hl & 0xffff) + lh;\n  const high = (hh + (hl >>> 16) + (carry >>> 16)) | 0;\n  const low = (carry << 16) | (ll & 0xffff);\n  return { h: high, l: low };\n}\n\nfunction mul2(a: number, b: number) {\n  // 2 * a * b (via shifts)\n  const { h, l } = mul(a, b);\n  return { h: ((h << 1) | (l >>> 31)) & 0xffff_ffff, l: (l << 1) & 0xffff_ffff };\n}\n\n// BlaMka permutation for Argon2\n// A + B + (2 * u32(A) * u32(B))\nfunction blamka(Ah: number, Al: number, Bh: number, Bl: number) {\n  const { h: Ch, l: Cl } = mul2(Al, Bl);\n  // A + B + (2 * A * B)\n  const Rll = add3L(Al, Bl, Cl);\n  return { h: add3H(Rll, Ah, Bh, Ch), l: Rll | 0 };\n}\n\n// Temporary block buffer\nconst A2_BUF = new Uint32Array(256); // 1024 bytes (matrix 16x16)\n\nfunction G(a: number, b: number, c: number, d: number) {\n  let Al = A2_BUF[2*a], Ah = A2_BUF[2*a + 1]; // prettier-ignore\n  let Bl = A2_BUF[2*b], Bh = A2_BUF[2*b + 1]; // prettier-ignore\n  let Cl = A2_BUF[2*c], Ch = A2_BUF[2*c + 1]; // prettier-ignore\n  let Dl = A2_BUF[2*d], Dh = A2_BUF[2*d + 1]; // prettier-ignore\n\n  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });\n\n  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });\n\n  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });\n\n  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });\n\n  (A2_BUF[2 * a] = Al), (A2_BUF[2 * a + 1] = Ah);\n  (A2_BUF[2 * b] = Bl), (A2_BUF[2 * b + 1] = Bh);\n  (A2_BUF[2 * c] = Cl), (A2_BUF[2 * c + 1] = Ch);\n  (A2_BUF[2 * d] = Dl), (A2_BUF[2 * d + 1] = Dh);\n}\n\n// prettier-ignore\nfunction P(\n  v00: number, v01: number, v02: number, v03: number, v04: number, v05: number, v06: number, v07: number,\n  v08: number, v09: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n) {\n  G(v00, v04, v08, v12);\n  G(v01, v05, v09, v13);\n  G(v02, v06, v10, v14);\n  G(v03, v07, v11, v15);\n  G(v00, v05, v10, v15);\n  G(v01, v06, v11, v12);\n  G(v02, v07, v08, v13);\n  G(v03, v04, v09, v14);\n}\n\nfunction block(x: Uint32Array, xPos: number, yPos: number, outPos: number, needXor: boolean) {\n  for (let i = 0; i < 256; i++) A2_BUF[i] = x[xPos + i] ^ x[yPos + i];\n  // columns (8)\n  for (let i = 0; i < 128; i += 16) {\n    // prettier-ignore\n    P(\n      i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7,\n      i + 8, i + 9, i + 10, i + 11, i + 12, i + 13, i + 14, i + 15\n    );\n  }\n  // rows (8)\n  for (let i = 0; i < 16; i += 2) {\n    // prettier-ignore\n    P(\n      i, i + 1, i + 16, i + 17, i + 32, i + 33, i + 48, i + 49,\n      i + 64, i + 65, i + 80, i + 81, i + 96, i + 97, i + 112, i + 113\n    );\n  }\n\n  if (needXor) for (let i = 0; i < 256; i++) x[outPos + i] ^= A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n  else for (let i = 0; i < 256; i++) x[outPos + i] = A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n  clean(A2_BUF);\n}\n\n// Variable-Length Hash Function H'\nfunction Hp(A: Uint32Array, dkLen: number) {\n  const A8 = u8(A);\n  const T = new Uint32Array(1);\n  const T8 = u8(T);\n  T[0] = dkLen;\n  // Fast path\n  if (dkLen <= 64) return blake2b.create({ dkLen }).update(T8).update(A8).digest();\n  const out = new Uint8Array(dkLen);\n  let V = blake2b.create({}).update(T8).update(A8).digest();\n  let pos = 0;\n  // First block\n  out.set(V.subarray(0, 32));\n  pos += 32;\n  // Rest blocks\n  for (; dkLen - pos > 64; pos += 32) {\n    const Vh = blake2b.create({}).update(V);\n    Vh.digestInto(V);\n    Vh.destroy();\n    out.set(V.subarray(0, 32), pos);\n  }\n  // Last block\n  out.set(blake2b(V, { dkLen: dkLen - pos }), pos);\n  clean(V, T);\n  return u32(out);\n}\n\n// Used only inside process block!\nfunction indexAlpha(\n  r: number,\n  s: number,\n  laneLen: number,\n  segmentLen: number,\n  index: number,\n  randL: number,\n  sameLane: boolean = false\n) {\n  // This is ugly, but close enough to reference implementation.\n  let area: number;\n  if (r === 0) {\n    if (s === 0) area = index - 1;\n    else if (sameLane) area = s * segmentLen + index - 1;\n    else area = s * segmentLen + (index == 0 ? -1 : 0);\n  } else if (sameLane) area = laneLen - segmentLen + index - 1;\n  else area = laneLen - segmentLen + (index == 0 ? -1 : 0);\n  const startPos = r !== 0 && s !== ARGON2_SYNC_POINTS - 1 ? (s + 1) * segmentLen : 0;\n  const rel = area - 1 - mul(area, mul(randL, randL).h).h;\n  return (startPos + rel) % laneLen;\n}\n\n/**\n * Argon2 options.\n * * t: time cost, m: mem cost in kb, p: parallelization.\n * * key: optional key. personalization: arbitrary extra data.\n * * dkLen: desired number of output bytes.\n */\nexport type ArgonOpts = {\n  t: number; // Time cost, iterations count\n  m: number; // Memory cost (in KB)\n  p: number; // Parallelization parameter\n  version?: number; // Default: 0x13 (19)\n  key?: KDFInput; // Optional key\n  personalization?: KDFInput; // Optional arbitrary extra data\n  dkLen?: number; // Desired number of returned bytes\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n  maxmem?: number;\n  onProgress?: (progress: number) => void;\n};\n\nconst maxUint32 = Math.pow(2, 32);\nfunction isU32(num: number) {\n  return Number.isSafeInteger(num) && num >= 0 && num < maxUint32;\n}\n\nfunction argon2Opts(opts: ArgonOpts) {\n  const merged: any = {\n    version: 0x13,\n    dkLen: 32,\n    maxmem: maxUint32 - 1,\n    asyncTick: 10,\n  };\n  for (let [k, v] of Object.entries(opts)) if (v != null) merged[k] = v;\n\n  const { dkLen, p, m, t, version, onProgress } = merged;\n  if (!isU32(dkLen) || dkLen < 4) throw new Error('dkLen should be at least 4 bytes');\n  if (!isU32(p) || p < 1 || p >= Math.pow(2, 24)) throw new Error('p should be 1 <= p < 2^24');\n  if (!isU32(m)) throw new Error('m should be 0 <= m < 2^32');\n  if (!isU32(t) || t < 1) throw new Error('t (iterations) should be 1 <= t < 2^32');\n  if (onProgress !== undefined && typeof onProgress !== 'function')\n    throw new Error('progressCb should be function');\n  /*\n  Memory size m MUST be an integer number of kibibytes from 8*p to 2^(32)-1. The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.\n  */\n  if (!isU32(m) || m < 8 * p) throw new Error('memory should be at least 8*p bytes');\n  if (version !== 0x10 && version !== 0x13) throw new Error('unknown version=' + version);\n  return merged;\n}\n\nfunction argon2Init(password: KDFInput, salt: KDFInput, type: Types, opts: ArgonOpts) {\n  password = kdfInputToBytes(password);\n  salt = kdfInputToBytes(salt);\n  abytes(password);\n  abytes(salt);\n  if (!isU32(password.length)) throw new Error('password should be less than 4 GB');\n  if (!isU32(salt.length) || salt.length < 8)\n    throw new Error('salt should be at least 8 bytes and less than 4 GB');\n  if (!Object.values(AT).includes(type)) throw new Error('invalid type');\n  let { p, dkLen, m, t, version, key, personalization, maxmem, onProgress, asyncTick } =\n    argon2Opts(opts);\n\n  // Validation\n  key = abytesOrZero(key);\n  personalization = abytesOrZero(personalization);\n  // H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||\n  //       LE32(v) || LE32(y) || LE32(length(P)) || P ||\n  //       LE32(length(S)) || S ||  LE32(length(K)) || K ||\n  //       LE32(length(X)) || X)\n  const h = blake2b.create({});\n  const BUF = new Uint32Array(1);\n  const BUF8 = u8(BUF);\n  for (let item of [p, dkLen, m, t, version, type]) {\n    BUF[0] = item;\n    h.update(BUF8);\n  }\n  for (let i of [password, salt, key, personalization]) {\n    BUF[0] = i.length; // BUF is u32 array, this is valid\n    h.update(BUF8).update(i);\n  }\n  const H0 = new Uint32Array(18);\n  const H0_8 = u8(H0);\n  h.digestInto(H0_8);\n  // 256 u32 = 1024 (BLOCK_SIZE), fills A2_BUF on processing\n\n  // Params\n  const lanes = p;\n  // m' = 4 * p * floor (m / 4p)\n  const mP = 4 * p * Math.floor(m / (ARGON2_SYNC_POINTS * p));\n  //q = m' / p columns\n  const laneLen = Math.floor(mP / p);\n  const segmentLen = Math.floor(laneLen / ARGON2_SYNC_POINTS);\n  const memUsed = mP * 256;\n  if (!isU32(maxmem) || memUsed > maxmem)\n    throw new Error(\n      'mem should be less than 2**32, got: maxmem=' + maxmem + ', memused=' + memUsed\n    );\n  const B = new Uint32Array(memUsed);\n  // Fill first blocks\n  for (let l = 0; l < p; l++) {\n    const i = 256 * laneLen * l;\n    // B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))\n    H0[17] = l;\n    H0[16] = 0;\n    B.set(Hp(H0, 1024), i);\n    // B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))\n    H0[16] = 1;\n    B.set(Hp(H0, 1024), i + 256);\n  }\n  let perBlock = () => {};\n  if (onProgress) {\n    const totalBlock = t * ARGON2_SYNC_POINTS * p * segmentLen;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlock / 10000), 1);\n    let blockCnt = 0;\n    perBlock = () => {\n      blockCnt++;\n      if (onProgress && (!(blockCnt % callbackPer) || blockCnt === totalBlock))\n        onProgress(blockCnt / totalBlock);\n    };\n  }\n  clean(BUF, H0);\n  return { type, mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick };\n}\n\nfunction argon2Output(B: Uint32Array, p: number, laneLen: number, dkLen: number) {\n  const B_final = new Uint32Array(256);\n  for (let l = 0; l < p; l++)\n    for (let j = 0; j < 256; j++) B_final[j] ^= B[256 * (laneLen * l + laneLen - 1) + j];\n  const res = u8(Hp(B_final, dkLen));\n  clean(B_final);\n  return res;\n}\n\nfunction processBlock(\n  B: Uint32Array,\n  address: Uint32Array,\n  l: number,\n  r: number,\n  s: number,\n  index: number,\n  laneLen: number,\n  segmentLen: number,\n  lanes: number,\n  offset: number,\n  prev: number,\n  dataIndependent: boolean,\n  needXor: boolean\n) {\n  if (offset % laneLen) prev = offset - 1;\n  let randL, randH;\n  if (dataIndependent) {\n    let i128 = index % 128;\n    if (i128 === 0) {\n      address[256 + 12]++;\n      block(address, 256, 2 * 256, 0, false);\n      block(address, 0, 2 * 256, 0, false);\n    }\n    randL = address[2 * i128];\n    randH = address[2 * i128 + 1];\n  } else {\n    const T = 256 * prev;\n    randL = B[T];\n    randH = B[T + 1];\n  }\n  // address block\n  const refLane = r === 0 && s === 0 ? l : randH % lanes;\n  const refPos = indexAlpha(r, s, laneLen, segmentLen, index, randL, refLane == l);\n  const refBlock = laneLen * refLane + refPos;\n  // B[i][j] = G(B[i][j-1], B[l][z])\n  block(B, 256 * prev, 256 * refBlock, offset * 256, needXor);\n}\n\nfunction argon2(type: Types, password: KDFInput, salt: KDFInput, opts: ArgonOpts) {\n  const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock } = argon2Init(\n    password,\n    salt,\n    type,\n    opts\n  );\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(\n            B,\n            address,\n            l,\n            r,\n            s,\n            index,\n            laneLen,\n            segmentLen,\n            lanes,\n            offset,\n            prev,\n            dataIndependent,\n            needXor\n          );\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n\n/** argon2d GPU-resistant version. */\nexport const argon2d = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argond2d, password, salt, opts);\n/** argon2i side-channel-resistant version. */\nexport const argon2i = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argon2i, password, salt, opts);\n/** argon2id, combining i+d, the most popular version from RFC 9106 */\nexport const argon2id = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argon2id, password, salt, opts);\n\nasync function argon2Async(type: Types, password: KDFInput, salt: KDFInput, opts: ArgonOpts) {\n  const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick } =\n    argon2Init(password, salt, type, opts);\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  let ts = Date.now();\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(\n            B,\n            address,\n            l,\n            r,\n            s,\n            index,\n            laneLen,\n            segmentLen,\n            lanes,\n            offset,\n            prev,\n            dataIndependent,\n            needXor\n          );\n          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n          const diff = Date.now() - ts;\n          if (!(diff >= 0 && diff < asyncTick)) {\n            await nextTick();\n            ts += diff;\n          }\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n\n/** argon2d async GPU-resistant version. */\nexport const argon2dAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argond2d, password, salt, opts);\n/** argon2i async side-channel-resistant version. */\nexport const argon2iAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argon2i, password, salt, opts);\n/** argon2id async, combining i+d, the most popular version from RFC 9106 */\nexport const argon2idAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argon2id, password, salt, opts);\n", "/**\n * Argon2id key derivation module.\n *\n * This module provides browser-compatible Argon2id key derivation using\n * the @noble/hashes library, which is pure JavaScript and works in all\n * modern browsers without WASM dependencies.\n *\n * Security note: The derived key is kept in memory as a CryptoKey object\n * and never serialized or persisted to disk.\n */\n\nimport { argon2id } from \"@noble/hashes/argon2\"\nimport type { Argon2idOptions, DerivedKey } from \"./types.js\"\n\n/**\n * Default Argon2id parameters optimized for password hashing in browsers.\n * These provide strong security without being prohibitively slow.\n */\nconst DEFAULT_OPTIONS: Required<Argon2idOptions> = {\n  iterations: 3,\n  parallelism: 4,\n  memorySize: 2 ** 16, // 64MB\n  hashLength: 32, // 256 bits for AES-256\n  type: \"id\",\n}\n\n/**\n * Derives a cryptographic key from a master password using Argon2id.\n *\n * @param masterPassword - The user's master password (will be cleared after use)\n * @param salt - Optional salt; if not provided, a random salt is generated\n * @param options - Optional Argon2id parameters\n * @returns DerivedKey object containing the derived CryptoKey and salt\n *\n * Security constraints:\n * - The returned key is a CryptoKey and cannot be inspected or serialized\n * - The salt is always returned so it can be stored alongside encrypted data\n * - The masterPassword buffer is NOT automatically cleared (caller's responsibility)\n */\nexport async function deriveKey(\n  masterPassword: string | Uint8Array,\n  salt?: Uint8Array,\n  options?: Argon2idOptions,\n): Promise<DerivedKey> {\n  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }\n\n  // Generate random salt if not provided\n  if (!salt) {\n    salt = crypto.getRandomValues(new Uint8Array(16))\n  }\n\n  // Convert master password to Uint8Array if needed\n  let passwordBytes: Uint8Array\n  if (typeof masterPassword === \"string\") {\n    passwordBytes = new TextEncoder().encode(masterPassword)\n  } else {\n    passwordBytes = masterPassword\n  }\n\n  // Derive key material using Argon2id\n  const derivedKeyMaterial = argon2id(passwordBytes, salt, {\n    t: mergedOptions.iterations,\n    m: mergedOptions.memorySize,\n    p: mergedOptions.parallelism,\n  })\n\n  // Import for AES-GCM (Encryption)\n  const encryptionKey = await crypto.subtle.importKey(\n    \"raw\",\n    derivedKeyMaterial.slice(0, mergedOptions.hashLength),\n    { name: \"AES-GCM\" },\n    false, // non-extractable\n    [\"encrypt\", \"decrypt\"],\n  )\n\n  // Import for HMAC-SHA256 (Authentication Proofs)\n  const authKey = await crypto.subtle.importKey(\n    \"raw\",\n    derivedKeyMaterial.slice(0, mergedOptions.hashLength),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false, // non-extractable\n    [\"sign\", \"verify\"],\n  )\n\n  return {\n    encryptionKey,\n    authKey,\n    salt,\n    key: encryptionKey, // Legacy alias\n  }\n}\n\n/**\n * Verifies that two master passwords would produce the same derived key.\n * Used during authentication to verify the master password without storing it.\n *\n * @param masterPassword - The password to verify\n * @param salt - The salt from the original derivation\n * @param referenceKey - A CryptoKey derived from the original password\n * @returns boolean indicating if the password matches\n *\n * Note: This function derives a new key and attempts a test decryption.\n * A failed decryption indicates an incorrect password.\n */\nexport async function verifyPassword(\n  masterPassword: string,\n  salt: Uint8Array,\n): Promise<boolean> {\n  try {\n    await deriveKey(masterPassword, salt)\n    // The actual verification happens during decryption attempt\n    // If this key can decrypt the test vector, the password is correct\n    return true // Caller uses this with actual decryption\n  } catch {\n    return false\n  }\n}\n", "/**\n * AES-256-GCM encryption module.\n *\n * Provides authenticated encryption for vault data using AES-256 in GCM mode.\n * GCM provides both confidentiality and authenticity, protecting against tampering.\n *\n * Security properties:\n * - 256-bit key (from Argon2id derivation)\n * - 96-bit random IV (nonce) generated per encryption\n * - Authentication tag included in ciphertext (prevents tampering)\n * - No plaintext is ever logged or stored\n */\n\nimport type { DerivedKey, EncryptedVault, VaultEntry } from \"./types.js\"\n\nconst ALGORITHM = \"AES-GCM\"\nconst IV_LENGTH = 12 // 96 bits - recommended for GCM\n// TAG_LENGTH is 128 bits (16 bytes) - automatically handled by GCM mode\n\n/**\n * Encrypts a vault entry using the derived key.\n *\n * @param entry - The vault entry to encrypt\n * @param derivedKey - The DerivedKey from deriveKey()\n * @returns EncryptedVault object with base64-encoded ciphertext, IV, and salt\n *\n * Security notes:\n * - A new random IV is generated for each encryption\n * - The IV is included in the output (standard practice for GCM)\n * - The salt is included so it can be stored with the encrypted data\n * - Authentication tag is automatically included by GCM mode\n */\nexport async function encrypt(entry: VaultEntry, derivedKey: DerivedKey): Promise<EncryptedVault> {\n  // Generate a random 96-bit IV for this encryption\n  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH))\n\n  // Serialize the vault entry to JSON\n  const plaintext = JSON.stringify(entry)\n  const plaintextBytes = new TextEncoder().encode(plaintext)\n\n  // Encrypt using AES-256-GCM\n  const ciphertext = await crypto.subtle.encrypt(\n    {\n      name: ALGORITHM,\n      iv,\n    },\n    derivedKey.encryptionKey,\n    plaintextBytes,\n  )\n\n  // Return serializable encrypted vault object\n  return {\n    ciphertext: bufferToBase64(new Uint8Array(ciphertext)),\n    iv: bufferToBase64(iv),\n    salt: bufferToBase64(derivedKey.salt),\n    algorithm: \"AES-256-GCM\",\n    derivationAlgorithm: \"Argon2id\",\n  }\n}\n\n/**\n * Decrypts a vault entry using the derived key.\n *\n * @param encrypted - The EncryptedVault object to decrypt\n * @param derivedKey - The DerivedKey from deriveKey()\n * @returns The decrypted VaultEntry, or an error if decryption fails\n *\n * Security notes:\n * - Failed decryption throws an error (wrong password or tampered ciphertext)\n * - The ciphertext includes an authentication tag that must be valid\n * - If authentication fails, the plaintext is never returned\n */\nexport async function decrypt(encrypted: EncryptedVault, derivedKey: DerivedKey): Promise<VaultEntry> {\n  const ciphertext = base64ToBuffer(encrypted.ciphertext)\n  const iv = base64ToBuffer(encrypted.iv)\n\n  try {\n    // Decrypt using AES-256-GCM\n    const plaintext = await crypto.subtle.decrypt(\n      {\n        name: ALGORITHM,\n        iv: iv as BufferSource,\n      },\n      derivedKey.encryptionKey,\n      ciphertext as BufferSource,\n    )\n\n    // Parse the decrypted JSON\n    const plaintextString = new TextDecoder().decode(plaintext)\n    const entry: VaultEntry = JSON.parse(plaintextString)\n\n    return entry\n  } catch (error) {\n    // GCM authentication failed (wrong password or tampered ciphertext)\n    throw new Error(\"Decryption failed. This could be due to incorrect password or corrupted data.\")\n  }\n}\n\n/**\n * Helper: Convert Uint8Array to base64 string.\n * Used for serializing binary data to JSON.\n */\nfunction bufferToBase64(buffer: Uint8Array): string {\n  let binary = \"\"\n  for (let i = 0; i < buffer.byteLength; i++) {\n    binary += String.fromCharCode(buffer[i])\n  }\n  return btoa(binary)\n}\n\n/**\n * Helper: Convert base64 string to Uint8Array.\n * Used for deserializing binary data from JSON.\n */\nfunction base64ToBuffer(base64: string): Uint8Array {\n  const binary = atob(base64)\n  const buffer = new Uint8Array(binary.length)\n  for (let i = 0; i < binary.length; i++) {\n    buffer[i] = binary.charCodeAt(i)\n  }\n  return buffer\n}\n", "/**\r\n * Background Service Worker - Manifest V3\r\n * \r\n * This is the security core of the extension. It:\r\n * - Holds the derived encryption key in memory (never persisted)\r\n * - Manages vault state and auto-lock timer\r\n * - Handles all cryptographic operations\r\n * - Communicates with popup and content scripts via message passing\r\n * \r\n * Security guarantees:\r\n * - Key exists only in memory\r\n * - Browser close destroys the key\r\n * - Extension reload requires re-authentication\r\n * - Auto-lock after inactivity\r\n */\r\n\r\nimport { deriveKey, encrypt, decrypt } from '@password-manager/crypto-engine'\r\nimport type { DerivedKey, VaultEntry, EncryptedVault } from '@password-manager/crypto-engine'\r\n\r\n// ============================================================================\r\n// SECURITY-CRITICAL: In-Memory State\r\n// ============================================================================\r\n\r\n// Local interface for extension's password entries\r\ninterface PasswordEntry {\r\n  id: string\r\n  siteName: string\r\n  siteUrl: string\r\n  username: string\r\n  password: string\r\n  notes?: string\r\n  createdAt: string\r\n  updatedAt: string\r\n}\r\n\r\ninterface SessionState {\r\n  userId: string | null\r\n  derivedKey: DerivedKey | null\r\n  decryptedVault: PasswordEntry[] | null\r\n  isLocked: boolean\r\n  lastActivity: number\r\n}\r\n\r\n\r\n// This state exists ONLY in memory and is destroyed on extension reload/browser close\r\nlet sessionState: SessionState = {\r\n  userId: null,\r\n  derivedKey: null,\r\n  decryptedVault: null,\r\n  isLocked: true,\r\n  lastActivity: Date.now()\r\n}\r\n\r\n// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\nconst AUTO_LOCK_TIMEOUT = 15 * 60 * 1000 // 15 minutes in milliseconds\r\nconst BACKEND_URL = 'http://localhost:3001' // Phase 2 backend\r\n\r\n// ============================================================================\r\n// Auto-Lock Timer\r\n// ============================================================================\r\n\r\nlet autoLockTimer: number | null = null\r\n\r\nfunction resetAutoLockTimer(): void {\r\n  sessionState.lastActivity = Date.now()\r\n  \r\n  if (autoLockTimer !== null) {\r\n    clearTimeout(autoLockTimer)\r\n  }\r\n  \r\n  autoLockTimer = setTimeout(() => {\r\n    lockVault()\r\n  }, AUTO_LOCK_TIMEOUT) as unknown as number\r\n}\r\n\r\nfunction lockVault(): void {\r\n  console.log('[Background] Locking vault and clearing sensitive data')\r\n  \r\n  // SECURITY: Explicitly clear all references to sensitive data\r\n  sessionState.userId = null\r\n  sessionState.derivedKey = null\r\n  sessionState.decryptedVault = null\r\n  sessionState.isLocked = true\r\n  \r\n  if (autoLockTimer !== null) {\r\n    clearTimeout(autoLockTimer)\r\n    autoLockTimer = null\r\n  }\r\n  \r\n  // Notify popup that vault is locked\r\n  chrome.runtime.sendMessage({ type: 'VAULT_LOCKED' }).catch(() => {\r\n    // Popup might not be open, ignore error\r\n  })\r\n}\r\n\r\n// ============================================================================\r\n// Message Handlers\r\n// ============================================================================\r\n\r\ninterface UnlockVaultMessage {\r\n  type: 'UNLOCK_VAULT'\r\n  masterPassword: string\r\n  userId: string\r\n}\r\n\r\ninterface AddPasswordMessage {\r\n  type: 'ADD_PASSWORD'\r\n  entry: PasswordEntry\r\n}\r\n\r\n\r\ninterface GetVaultMessage {\r\n  type: 'GET_VAULT'\r\n}\r\n\r\ninterface LockVaultMessage {\r\n  type: 'LOCK_VAULT'\r\n}\r\n\r\ninterface GetStatusMessage {\r\n  type: 'GET_STATUS'\r\n}\r\n\r\ninterface HeartbeatMessage {\r\n  type: 'HEARTBEAT'\r\n}\r\n\r\ninterface DeletePasswordMessage {\r\n  type: 'DELETE_PASSWORD'\r\n  entryId: string\r\n}\r\n\r\ninterface UpdatePasswordMessage {\r\n  type: 'UPDATE_PASSWORD'\r\n  entry: PasswordEntry\r\n}\r\n\r\ninterface RegisterUserMessage {\r\n  type: 'REGISTER_USER'\r\n  email: string\r\n  masterPassword: string\r\n}\r\n\r\n\r\ntype BackgroundMessage = \r\n  | UnlockVaultMessage \r\n  | AddPasswordMessage \r\n  | GetVaultMessage \r\n  | LockVaultMessage\r\n  | GetStatusMessage\r\n  | HeartbeatMessage\r\n  | DeletePasswordMessage\r\n  | UpdatePasswordMessage\r\n  | RegisterUserMessage\r\n\r\n\r\n\r\nchrome.runtime.onMessage.addListener((message: BackgroundMessage, sender, sendResponse) => {\r\n  console.log('[Background] Received message:', message.type)\r\n  \r\n  // Handle messages asynchronously\r\n  handleMessage(message, sender)\r\n    .then(sendResponse)\r\n    .catch((error) => {\r\n      console.error('[Background] Error handling message:', error)\r\n      sendResponse({ success: false, error: error.message })\r\n    })\r\n  \r\n  // Return true to indicate async response\r\n  return true\r\n})\r\n\r\nasync function handleMessage(message: BackgroundMessage, sender: chrome.runtime.MessageSender): Promise<any> {\r\n  switch (message.type) {\r\n    case 'UNLOCK_VAULT':\r\n      return await handleUnlockVault(message)\r\n    \r\n    case 'ADD_PASSWORD':\r\n      return await handleAddPassword(message)\r\n    \r\n    case 'DELETE_PASSWORD':\r\n      return await handleDeletePassword(message)\r\n\r\n    case 'UPDATE_PASSWORD':\r\n      return await handleUpdatePassword(message)\r\n    \r\n    case 'GET_VAULT':\r\n      return handleGetVault()\r\n    \r\n    case 'LOCK_VAULT':\r\n      return handleLockVault()\r\n    \r\n    case 'GET_STATUS':\r\n      return handleGetStatus()\r\n    \r\n    case 'HEARTBEAT':\r\n      resetAutoLockTimer() // Keep session alive\r\n      return { success: true }\r\n    \r\n    case 'REGISTER_USER':\r\n      return await handleRegisterUser(message)\r\n\r\n    default:\r\n      return Promise.resolve({ success: false, error: 'Unknown message type' })\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Unlock Vault Handler\r\n// ============================================================================\r\n\r\nasync function handleUnlockVault(message: UnlockVaultMessage): Promise<{ success: boolean; error?: string }> {\r\n  try {\r\n    console.log('[Background] Unlocking vault for user:', message.userId)\r\n    \r\n    // Step 1: Fetch encrypted vault from backend\r\n    const response = await fetch(`${BACKEND_URL}/api/vault/${message.userId}`)\r\n    \r\n    if (!response.ok) {\r\n      if (response.status === 404) {\r\n        // New user - create empty vault\r\n        console.log('[Background] No vault found, creating new vault')\r\n        \r\n        // Derive key from master password\r\n        const derivedKey = await deriveKey(message.masterPassword)\r\n        \r\n        // Create empty vault\r\n        const emptyVault: PasswordEntry[] = []\r\n        // SECURITY: We use JSON.stringify(emptyVault) to treat the whole list as the secret payload\r\n        const encryptedVault = await encrypt({ site: 'VAULT_ROOT', username: 'SYSTEM', password: JSON.stringify(emptyVault) }, derivedKey)\r\n        \r\n        // Save to backend\r\n        await saveVault(message.userId, encryptedVault, [])\r\n        \r\n        // Store in session\r\n        sessionState.userId = message.userId\r\n        sessionState.derivedKey = derivedKey\r\n        sessionState.decryptedVault = emptyVault\r\n        sessionState.isLocked = false\r\n        \r\n        resetAutoLockTimer()\r\n        \r\n        return { success: true }\r\n\r\n      }\r\n      \r\n      throw new Error(`Backend error: ${response.statusText}`)\r\n    }\r\n    \r\n    const encryptedVault: EncryptedVault = await response.json()\r\n    \r\n    // Step 2: Derive key from master password\r\n    // SECURITY: Use the salt from the encrypted vault\r\n    const salt = base64ToBuffer(encryptedVault.salt)\r\n    const derivedKey = await deriveKey(message.masterPassword, salt)\r\n    \r\n    // Step 3: Decrypt vault\r\n    // This will throw if the password is incorrect\r\n    const rootEntry = await decrypt(encryptedVault, derivedKey)\r\n    const decryptedVault: PasswordEntry[] = JSON.parse(rootEntry.password) \r\n    // Step 4: Store in memory (NEVER persist to disk)\r\n    sessionState.userId = message.userId\r\n    sessionState.derivedKey = derivedKey\r\n    sessionState.decryptedVault = decryptedVault\r\n    sessionState.isLocked = false\r\n\r\n    \r\n    // Step 5: Start auto-lock timer\r\n    resetAutoLockTimer()\r\n    \r\n    console.log('[Background] Vault unlocked successfully')\r\n    \r\n    return { success: true }\r\n    \r\n  } catch (error: any) {\r\n    console.error('[Background] Failed to unlock vault:', error)\r\n    \r\n    // Clear any partial state\r\n    sessionState.userId = null\r\n    sessionState.derivedKey = null\r\n    sessionState.decryptedVault = null\r\n    sessionState.isLocked = true\r\n    \r\n    return { \r\n      success: false, \r\n      error: error.message || 'Failed to unlock vault. Check your master password.' \r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Register User Handler\r\n// ============================================================================\r\n\r\nasync function handleRegisterUser(message: RegisterUserMessage): Promise<{ success: boolean; error?: string }> {\r\n  try {\r\n    console.log('[Background] Registering new user:', message.email)\r\n    \r\n    // Step 1: Generate salt and derive keys\r\n    const salt = crypto.getRandomValues(new Uint8Array(16))\r\n    const derivedKey = await deriveKey(message.masterPassword, salt)\r\n    \r\n    // Step 2: Create auth proof (verifier)\r\n    const encoder = new TextEncoder()\r\n    const proofData = encoder.encode(\"auth-proof\")\r\n    const proofBuffer = await crypto.subtle.sign(\"HMAC\", derivedKey.authKey, proofData)\r\n    const verifier = Array.from(new Uint8Array(proofBuffer))\r\n      .map((b) => b.toString(16).padStart(2, \"0\"))\r\n      .join(\"\")\r\n\r\n    const saltHex = Array.from(salt)\r\n      .map((b) => b.toString(16).padStart(2, \"0\"))\r\n      .join(\"\")\r\n\r\n    // Step 3: Register with backend\r\n    const regResponse = await fetch(`${BACKEND_URL}/auth/register`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        email: message.email,\r\n        salt: saltHex,\r\n        verifier: verifier\r\n      })\r\n    })\r\n\r\n    if (!regResponse.ok) {\r\n      const errorData = await regResponse.json()\r\n      throw new Error(errorData.message || errorData.error || 'Registration failed')\r\n    }\r\n\r\n    const regData = await regResponse.json()\r\n    console.log('[Background] User registered successfully, ID:', regData.userId)\r\n\r\n    // Step 4: Initialize an empty vault for the new user\r\n    const emptyVault: PasswordEntry[] = []\r\n    const encryptedVault = await encrypt({ \r\n      site: 'VAULT_ROOT', \r\n      username: 'SYSTEM', \r\n      password: JSON.stringify(emptyVault) \r\n    }, derivedKey)\r\n    \r\n    // Save to backend\r\n    await saveVault(message.email, encryptedVault, [])\r\n    \r\n    // Step 5: Store in memory to \"log in\" the user immediately\r\n    sessionState.userId = message.email\r\n    sessionState.derivedKey = derivedKey\r\n    sessionState.decryptedVault = emptyVault\r\n    sessionState.isLocked = false\r\n    \r\n    resetAutoLockTimer()\r\n    \r\n    return { success: true }\r\n\r\n  } catch (error: any) {\r\n    console.error('[Background] Registration failed:', error)\r\n    return { success: false, error: error.message }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Add Password Handler\r\n// ============================================================================\r\n\r\nasync function handleAddPassword(message: AddPasswordMessage): Promise<{ success: boolean; error?: string }> {\r\n  if (sessionState.isLocked || !sessionState.derivedKey || !sessionState.decryptedVault) {\r\n    return { success: false, error: 'Vault is locked' }\r\n  }\r\n  \r\n  try {\r\n    // Add entry to decrypted vault\r\n    sessionState.decryptedVault.push(message.entry)\r\n    \r\n    // Re-encrypt and save to backend\r\n    const encryptedVault = await encrypt({ site: 'VAULT_ROOT', username: 'SYSTEM', password: JSON.stringify(sessionState.decryptedVault) }, sessionState.derivedKey) \r\n    \r\n    // Extract plaintext labels for server identification\r\n    const labels = sessionState.decryptedVault.map(e => e.siteName)\r\n    \r\n    await saveVault(sessionState.userId!, encryptedVault, labels)\r\n    \r\n    resetAutoLockTimer()\r\n    \r\n    return { success: true }\r\n    \r\n  } catch (error: any) {\r\n    console.error('[Background] Failed to add password:', error)\r\n    return { success: false, error: error.message }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Get Vault Handler\r\n// ============================================================================\r\n\r\nfunction handleGetVault(): { success: boolean; vault?: PasswordEntry[]; error?: string } {\r\n  if (sessionState.isLocked || !sessionState.decryptedVault) {\r\n    return { success: false, error: 'Vault is locked' }\r\n  }\r\n  \r\n  resetAutoLockTimer()\r\n  \r\n  return { \r\n    success: true, \r\n    vault: sessionState.decryptedVault \r\n  }\r\n}\r\n\r\n\r\n// ============================================================================\r\n// Delete Password Handler\r\n// ============================================================================\r\n\r\nasync function handleDeletePassword(message: DeletePasswordMessage): Promise<{ success: boolean; error?: string }> {\r\n  if (sessionState.isLocked || !sessionState.derivedKey || !sessionState.decryptedVault) {\r\n    return { success: false, error: 'Vault is locked' }\r\n  }\r\n\r\n  try {\r\n    // Remove entry from decrypted vault\r\n    sessionState.decryptedVault = sessionState.decryptedVault.filter(e => e.id !== message.entryId)\r\n\r\n    // Re-encrypt and save to backend\r\n    const encryptedVault = await encrypt({ site: 'VAULT_ROOT', username: 'SYSTEM', password: JSON.stringify(sessionState.decryptedVault) }, sessionState.derivedKey)\r\n    \r\n    const labels = sessionState.decryptedVault.map(e => e.siteName)\r\n    await saveVault(sessionState.userId!, encryptedVault, labels)\r\n\r\n    resetAutoLockTimer()\r\n    return { success: true }\r\n\r\n  } catch (error: any) {\r\n    console.error('[Background] Failed to delete password:', error)\r\n    return { success: false, error: error.message }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Update Password Handler\r\n// ============================================================================\r\n\r\nasync function handleUpdatePassword(message: UpdatePasswordMessage): Promise<{ success: boolean; error?: string }> {\r\n  if (sessionState.isLocked || !sessionState.derivedKey || !sessionState.decryptedVault) {\r\n    return { success: false, error: 'Vault is locked' }\r\n  }\r\n\r\n  try {\r\n    // Update entry in decrypted vault\r\n    const index = sessionState.decryptedVault.findIndex(e => e.id === message.entry.id)\r\n    if (index === -1) {\r\n      return { success: false, error: 'Entry not found' }\r\n    }\r\n\r\n    sessionState.decryptedVault[index] = {\r\n      ...message.entry,\r\n      updatedAt: new Date().toISOString()\r\n    }\r\n\r\n    // Re-encrypt and save to backend\r\n    const encryptedVault = await encrypt({ site: 'VAULT_ROOT', username: 'SYSTEM', password: JSON.stringify(sessionState.decryptedVault) }, sessionState.derivedKey)\r\n    \r\n    const labels = sessionState.decryptedVault.map(e => e.siteName)\r\n    await saveVault(sessionState.userId!, encryptedVault, labels)\r\n\r\n    resetAutoLockTimer()\r\n    return { success: true }\r\n\r\n  } catch (error: any) {\r\n    console.error('[Background] Failed to update password:', error)\r\n    return { success: false, error: error.message }\r\n  }\r\n}\r\n\r\n\r\n// ============================================================================\r\n// Lock Vault Handler\r\n// ============================================================================\r\n\r\nfunction handleLockVault(): { success: boolean } {\r\n  lockVault()\r\n  return { success: true }\r\n}\r\n\r\n// ============================================================================\r\n// Get Status Handler\r\n// ============================================================================\r\n\r\nfunction handleGetStatus(): { isLocked: boolean } {\r\n  return { isLocked: sessionState.isLocked }\r\n}\r\n\r\nasync function saveVault(userId: string, encryptedVault: EncryptedVault, labels: string[]): Promise<void> {\r\n  const response = await fetch(`${BACKEND_URL}/api/vault/${userId}`, {\r\n    method: 'PUT',\r\n    headers: { 'Content-Type': 'application/json' },\r\n    body: JSON.stringify({\r\n      encryptedVault,\r\n      labels\r\n    })\r\n  })\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`Failed to save vault: ${response.statusText}`)\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\nfunction base64ToBuffer(base64: string): Uint8Array {\r\n  try {\r\n    const binary = atob(base64)\r\n    const buffer = new Uint8Array(binary.length)\r\n    for (let i = 0; i < binary.length; i++) {\r\n        buffer[i] = binary.charCodeAt(i)\r\n    }\r\n    return buffer\r\n  } catch (error) {\r\n    console.error('[Background] Failed to decode base64:', error)\r\n    return new Uint8Array(0)\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Extension Lifecycle\r\n// ============================================================================\r\n\r\nchrome.runtime.onInstalled.addListener(() => {\r\n  console.log('[Background] Extension installed')\r\n})\r\n\r\nchrome.runtime.onStartup.addListener(() => {\r\n  console.log('[Background] Browser started - vault is locked by default')\r\n})\r\n\r\n// SECURITY: When service worker is terminated, all state is lost\r\n// This is a FEATURE, not a bug - it ensures the key is never persisted\r\nconsole.log('[Background] Service worker initialized - vault is locked')\r\n"],
  "mappings": "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",
  "names": ["U32_MASK64", "_32n", "fromBig", "n", "le", "rotrSH", "h", "l", "s", "rotrSL", "rotrBH", "rotrBL", "rotr32H", "_h", "rotr32L", "_l", "add", "Ah", "Al", "Bh", "Bl", "l", "add3L", "Cl", "add3H", "low", "Ch", "isBytes", "a", "anumber", "n", "abytes", "b", "lengths", "aexists", "instance", "checkFinished", "aoutput", "out", "abytes", "min", "u8", "arr", "u32", "clean", "arrays", "i", "isLE", "byteSwap", "word", "swap8IfBE", "n", "byteSwap32", "arr", "i", "byteSwap", "swap32IfBE", "isLE", "u", "utf8ToBytes", "str", "toBytes", "data", "utf8ToBytes", "abytes", "kdfInputToBytes", "Hash", "createOptHasher", "hashCons", "hashC", "msg", "opts", "toBytes", "tmp", "BSIGMA", "B2B_IV", "BBUF", "G1b", "a", "b", "c", "d", "msg", "x", "Xl", "Xh", "Al", "Ah", "Bl", "Bh", "Cl", "Ch", "Dl", "Dh", "ll", "add3L", "add3H", "rotr32H", "rotr32L", "add", "rotrSH", "rotrSL", "G2b", "rotrBH", "rotrBL", "checkBlake2Opts", "outputLen", "opts", "keyLen", "saltLen", "persLen", "anumber", "key", "salt", "personalization", "BLAKE2", "Hash", "blockLen", "u32", "data", "aexists", "toBytes", "abytes", "buffer", "buffer32", "len", "offset", "buf", "pos", "swap32IfBE", "take", "dataOffset", "data32", "pos32", "out", "aoutput", "clean", "out32", "v", "i", "swap8IfBE", "res", "to", "length", "finished", "destroyed", "BLAKE2b", "olen", "keyLength", "slt", "pers", "tmp", "v0l", "v0h", "v1l", "v1h", "v2l", "v2h", "v3l", "v3h", "v4l", "v4h", "v5l", "v5h", "v6l", "v6h", "v7l", "v7h", "isLast", "h", "l", "fromBig", "j", "BSIGMA", "blake2b", "createOptHasher", "AT", "ARGON2_SYNC_POINTS", "abytesOrZero", "buf", "kdfInputToBytes", "mul", "a", "b", "aL", "aH", "bL", "bH", "ll", "hl", "lh", "hh", "carry", "high", "low", "mul2", "h", "l", "blamka", "Ah", "Al", "Bh", "Bl", "Ch", "Cl", "Rll", "add3L", "add3H", "A2_BUF", "G", "c", "d", "Dl", "Dh", "rotr32H", "rotr32L", "rotrSH", "rotrSL", "rotrBH", "rotrBL", "P", "v00", "v01", "v02", "v03", "v04", "v05", "v06", "v07", "v08", "v09", "v10", "v11", "v12", "v13", "v14", "v15", "block", "x", "xPos", "yPos", "outPos", "needXor", "i", "clean", "Hp", "A", "dkLen", "A8", "u8", "T", "T8", "blake2b", "out", "V", "pos", "Vh", "u32", "indexAlpha", "r", "s", "laneLen", "segmentLen", "index", "randL", "sameLane", "area", "startPos", "rel", "maxUint32", "isU32", "num", "argon2Opts", "opts", "merged", "k", "v", "p", "m", "t", "version", "onProgress", "argon2Init", "password", "salt", "type", "abytes", "key", "personalization", "maxmem", "asyncTick", "BUF", "BUF8", "item", "H0", "H0_8", "lanes", "mP", "memUsed", "B", "perBlock", "totalBlock", "callbackPer", "blockCnt", "argon2Output", "B_final", "j", "res", "processBlock", "address", "offset", "prev", "dataIndependent", "randH", "i128", "refLane", "refPos", "refBlock", "argon2", "argon2id", "password", "salt", "opts", "argon2", "AT", "DEFAULT_OPTIONS", "deriveKey", "masterPassword", "salt", "options", "mergedOptions", "passwordBytes", "derivedKeyMaterial", "argon2id", "encryptionKey", "authKey", "ALGORITHM", "encrypt", "entry", "derivedKey", "iv", "plaintext", "plaintextBytes", "ciphertext", "ALGORITHM", "bufferToBase64", "decrypt", "encrypted", "base64ToBuffer", "plaintextString", "buffer", "binary", "i", "base64", "sessionState", "AUTO_LOCK_TIMEOUT", "BACKEND_URL", "autoLockTimer", "resetAutoLockTimer", "lockVault", "message", "sender", "sendResponse", "handleMessage", "error", "handleUnlockVault", "handleAddPassword", "handleDeletePassword", "handleUpdatePassword", "handleGetVault", "handleLockVault", "handleGetStatus", "handleRegisterUser", "response", "derivedKey", "deriveKey", "emptyVault", "encryptedVault", "encrypt", "saveVault", "salt", "base64ToBuffer", "rootEntry", "decrypt", "decryptedVault", "proofData", "proofBuffer", "verifier", "b", "saltHex", "regResponse", "errorData", "regData", "labels", "e", "index", "userId", "base64", "binary", "buffer", "i"]
}
